#!/usr/bin/env perl

use warnings;
use strict;

## 20180407 - I had code in here that discarded reads that mapped to multiple genes - but that ignores priority (ie don't want to throw away a 3'utr read because it overlaps a crappy lncRNA) - fixed

## Note 2015/11/12 - this script takes in ucsc table format data from gencode (now manually generated by me based off of gencode GTF files), which are 0-based open ended
# &read_gencode converts those features to 1-based, closed ended features for overlaps with reads from sam format (also 1-based, closed ended)

my $verbose_flag = 0;
my $hashing_value = 10000;

my $window_size = 100;

my %merge_region_types;
for my $region_type ("5utr","CDS","3utr","noncoding_exon") {
    $merge_region_types{$region_type} = "allexonic";
}
for my $region_type ("5ss","3ss","proxintron","distintron","noncoding_5ss","noncoding_3ss","noncoding_proxintron","noncoding_distintron") {
    $merge_region_types{$region_type} = "allintronic";
}


my %all_features;
my %enst2type;
my %enst2ensg;
my %ensg2name;
my %ensg2type;

my $clip_fi1 = $ARGV[0];
my $gencode_gtf_file = $ARGV[1];
my $gencode_tablebrowser_file = $ARGV[2];
my $trna_bed = $ARGV[3];
my $lncrna_tablefile = $ARGV[4];
my $lncrna_fullfi = $ARGV[5];
my $output_fi = $ARGV[6];

#defaults to hg19

# my $trna_bed = "/home/elvannostrand/data/clip/CLIPseq_analysis/scripts/hg19-tRNAs.bed";
# my $gencode_gtf_file = "/projects/ps-yeolab/genomes/hg19/gencode_v19/gencode.v19.chr_patch_hapl_scaff.annotation.gtf";
# my $gencode_tablebrowser_file = "/projects/ps-yeolab/genomes/hg19/gencode_v19/gencode.v19.chr_patch_hapl_scaff.annotation.gtf.parsed_ucsc_tableformat";
# my $lncrna_tablefile = "/home/elvannostrand/data/clip/CLIPseq_analysis/lncRNAs/lncipedia_5_0_hg19.bed.parsed_ucsc_tableformat";
# my $lncrna_fullfi = "/home/elvannostrand/data/clip/CLIPseq_analysis/lncRNAs/lncipedia_5_0_hg19.gff.parsed";

open(OUT,">$output_fi");

&read_lncrna_parsed($lncrna_fullfi) unless ($lncrna_fullfi eq "NA");
&read_gencode_gtf($gencode_gtf_file);
&read_gencode($gencode_tablebrowser_file);
&read_gencode($lncrna_tablefile) unless ($lncrna_tablefile eq "NA");

my %readcounts_by_region;

&parse_trna_list($trna_bed);


&read_bam_fi($clip_fi1);

my @final_feature_types = ("tRNA","CDS","3utr","5utr","5ss","3ss","proxintron","distintron","noncoding_exon","noncoding_5ss","noncoding_3ss","noncoding_proxintron","noncoding_distintron","allexonic","allintronic","all");

#my @final_feature_types = ("CDS","5utr","3utr","5utr|3utr","intron","intergenic","noncoding_exon","noncoding_intron");
print OUT "ENSG";
for my $feature_type (@final_feature_types) {
    print OUT "\t$feature_type";
}
print OUT "\n";

for my $key (keys %readcounts_by_region) {
    print OUT "$key";
    for my $feature_type (@final_feature_types) {
	my $toprint = 0;
	if (exists $readcounts_by_region{$key}{$feature_type}) {
	    $toprint = $readcounts_by_region{$key}{$feature_type};
	}
	print OUT "\t$toprint";
    }
    print OUT "\n";
    
}


sub read_bam_fi {
    my $bamfile = shift;

    print STDERR "now doing $bamfile\n";
    if ($bamfile =~ /\.bam/) {
        open(B,"samtools view -h $bamfile |") || die "no $bamfile\n";
    } elsif ($bamfile =~ /\.sam/) {
        open(B,$bamfile) || die "no sam $bamfile\n";
    } else {
        print STDERR "file format error not .sam or .bam \n";
        exit;
    }
    while (<B>) {
        my $r1 = $_;

	$verbose_flag = 0;

        if ($r1 =~ /^\@/) {
            next;
        }
        my @tmp_r1 = split(/\t/,$r1);
        my @read_name = split(/\:/,$tmp_r1[0]);
        my $randommer = $read_name[0];

        my $r1_cigar = $tmp_r1[5];
        my $r1sam_flag = $tmp_r1[1];
        my $mismatch_flags = $tmp_r1[14];

        my $r1_chr = $tmp_r1[2];
        my $r1_start = $tmp_r1[3];

        my $frag_strand;
	if ($r1sam_flag == 147) {
#        if ($r1sam_flag == 16) {
            $frag_strand = "-";
        } elsif ($r1sam_flag == 163) {
            $frag_strand = "+";
        } else {
	    next;
            print STDERR "R1 strand error $r1sam_flag\n";
        }

	my @read_regions = &parse_cigar_string($r1_start,$r1_cigar,$r1_chr,$frag_strand);

	my $feature_flag = 0;
        my %tmp_hash;
	my %tmp_ensttype_hash;
        for my $region (@read_regions) {
	    
	    my ($rchr,$rstr,$rpos) = split(/\:/,$region);
            my ($rstart,$rstop) = split(/\-/,$rpos);
	    
            my $rx = int($rstart / $hashing_value);
            my $ry = int($rstop  / $hashing_value);
            for my $ri ($rx..$ry) {
		for my $feature (@{$all_features{$rchr}{$rstr}{$ri}}) {
		    my ($feature_enst,$feature_type,$feature_region) = split(/\|/,$feature);
		    my ($feature_start,$feature_stop) = split(/\-/,$feature_region);

		    next if ($rstop <= $feature_start);
		    next if ($rstart >= $feature_stop);
		    my $overlap_start = &max($feature_start,$rstart);
		    my $overlap_stop  = &min($feature_stop,$rstop);
		    my $feature_ensg = $enst2ensg{$feature_enst};
		    if ($feature_start == $feature_stop) {
			print STDERR "0 base feature $feature\n";
			next;
		    }
		    $tmp_hash{$feature_ensg}{$feature_enst}{$feature_type} = ($overlap_stop - $overlap_start)/($feature_stop-$feature_start);

		    my $enst_type = $enst2type{$feature_enst};
		    $tmp_ensttype_hash{$enst_type}{$feature_ensg} = 1;

		    $feature_flag = 1;

		    print "found feature $_ $feature $feature_ensg $feature_type\n" if ($verbose_flag == 1);
		}
	    }
	}

	if ($feature_flag == 1) {
	    # removing reads that map to more than one ENSG id
	    
	    my %ensg_list;
	    if (exists $tmp_ensttype_hash{"tRNA"}) {
		%ensg_list = %{$tmp_ensttype_hash{"tRNA"}};
	    } elsif (exists $tmp_ensttype_hash{"protein_coding"}) {
		%ensg_list = %{$tmp_ensttype_hash{"protein_coding"}};
	    } else {
		%ensg_list = %tmp_hash;
	    }

#	    next if (scalar(keys %tmp_hash) > 1);
#	    for my $feature_ensg (keys %tmp_hash) {
	    next if (scalar(keys %ensg_list) > 1);
	    for my $feature_ensg (keys %ensg_list) {
		
		my %enst_feature_type_hash;
		for my $feature_enst (keys %{$tmp_hash{$feature_ensg}}) {
		    my %enst_types = %{$tmp_hash{$feature_ensg}{$feature_enst}};
		    my $enst_feature_type = &choose_enst_type(\%enst_types);
		    $enst_feature_type_hash{$enst_feature_type} = 1;
		}


		my $final_feature_type = "intergenic";
	      TYPELOOP:         for my $feature_type ("tRNA","CDS","3utr","5utr","5ss","3ss","proxintron","distintron","noncoding_exon","noncoding_5ss","noncoding_3ss","noncoding_proxintron","noncoding_distintron") {
		  if (exists $enst_feature_type_hash{$feature_type}) {
		      $final_feature_type = $feature_type;
		      last TYPELOOP;
		  }
	      }

		print "adding to $feature_ensg $final_feature_type \n" if ($verbose_flag == 1);
		$readcounts_by_region{$feature_ensg}{$final_feature_type} ++;
		$readcounts_by_region{$feature_ensg}{all} ++;
		$readcounts_by_region{all}{$final_feature_type} ++;
		$readcounts_by_region{all}{all} ++;
		$readcounts_by_region{$feature_ensg}{$merge_region_types{$final_feature_type}}++ if (exists $merge_region_types{$final_feature_type});
		$readcounts_by_region{all}{$merge_region_types{$final_feature_type}}++ if (exists $merge_region_types{$final_feature_type});

	    }
	} else {
	    my $final_feature_type = "intergenic";
	    print "adding to all $final_feature_type \n" if ($verbose_flag == 1);
	    $readcounts_by_region{all}{$final_feature_type} ++;
	    $readcounts_by_region{all}{all} ++;
	    $readcounts_by_region{"intergenic"}{all}++;
	}
    }
    close(B);
}


sub parse_trna_list {
    my $trna_fi = shift;
    open(TRNA,$trna_fi);
    for my $line (<TRNA>) {
        chomp($line);
        my @tmp = split(/\t/,$line);
        my $chr = $tmp[0];
        # trna file is 1 based closed ended - shifting to bed format [0 base open ended) here                                                                               
        my $start = $tmp[1]-1;
        my $stop = $tmp[2];
        my $str = $tmp[5];
        my $id = $tmp[3];

        my $x = int($start/$hashing_value);
        my $y = int($stop /$hashing_value);

        my $feature = $id."|tRNA|".$start."-".$stop;
        $enst2ensg{$id} = $id;
	$enst2type{$id} = "tRNA";
        for my $j ($x..$y) {
            push @{$all_features{$chr}{$str}{$j}},$feature;
        }
    }
    close(TRNA);

}



sub choose_enst_type {
    my $ref = shift;
    my %enst_types = %$ref;

    my $enst_feature_type = "intergenic";

    if (exists $enst_types{"tRNA"}) {
	return("tRNA");
    }

# this works because an ENST can only either be coding or non-coding; so if it's coding it can't possibly have noncoding_intron flags and will skip them
    
    my @intronic_features = ("5ss","3ss","proxintron","distintron","noncoding_5ss","noncoding_3ss","noncoding_proxintron","noncoding_distintron");
    for my $intronic_feature_type (@intronic_features) {
	if (exists $enst_types{$intronic_feature_type}) {
	    $enst_feature_type = &max_from_hash(\%enst_types,join("|",@intronic_features));
	    return($enst_feature_type);
	}
    }

    my @exonic_features = ("5utr","CDS","3utr","noncoding_exon");
    for my $exonic_feature_type (@exonic_features) {
	if (exists $enst_types{$exonic_feature_type}) {
            $enst_feature_type = &max_from_hash(\%enst_types,join("|",@exonic_features));
	    return($enst_feature_type);
	}
    }

    return($enst_feature_type);
}


sub max_from_hash {
    my $ref = shift;
    my %hashref = %$ref;

    my $desired = shift;
    my @desired_array = split(/\|/,$desired);
    
    my $current_max = "NA";
    my $max_element;
    for my $des (@desired_array) {
	next unless (exists $hashref{$des});
	if ($current_max eq "NA" || $hashref{$des} > $current_max) {
	    $max_element = $des;
	    $current_max = $hashref{$des};
	}
    }
    
    return($max_element);
}

sub max {
    my $x = shift;
    my $y = shift;
    if ($x > $y) {
	return($x);
    } else {
	return($y);
    }
}

sub min {
    my $x = shift;
    my $y = shift;
    if ($x < $y) {
        return($x);
    } else {
        return($y);
    }
}


sub parse_cigar_string {
    my $region_start_pos = shift;
    my $flags = shift;
    my $chr = shift;
    my $strand = shift;

    my $current_pos = $region_start_pos;
    my @regions;

    while ($flags =~ /(\d+)([A-Z])/g) {
       
        if ($2 eq "N") {
            #read has intron of N bases at location

            # 1 based, closed ended to 0 based, right side open ended fix                                                                                                     
            push @regions,$chr.":".$strand.":".($region_start_pos-1)."-".($current_pos-1);
#            push @regions,$chr.":".$strand.":".$region_start_pos."-".($current_pos-1);

            $current_pos += $1;
            $region_start_pos = $current_pos;
        } elsif ($2 eq "M") {
            #read and genome match
            $current_pos += $1;
        } elsif ($2 eq "S") {
            #beginning of read is soft-clipped; mapped pos is actually start pos of mapping not start of read
        } elsif ($2 eq "I") {
            #read has insertion relative to genome; doesn't change genome position
        } elsif ($2 eq "D") {
#           push @read_regions,$chr.":".$current_pos."-".($current_pos+=$1);
            $current_pos += $1;
            #read has deletion relative to genome; genome position has to increase
        } else {
            print STDERR "flag $1 $2 $flags\n";

        }
    }
# 1 based, closed ended to 0 based, right side open ended fix                                                                                                               
# $region_start_pos is 1-based, closed ended -> ($region_start_pos-1) is 0-based, closed ended                                                                              
# ($current_pos-1) is 1-based, closed ended -> ($current_pos-1-1) is 0-based, closed ended -> ($current_pos-1-1+1) is 0-based, open ended                                   

#    push @regions,$chr.":".$strand.":".$region_start_pos."-".($current_pos-1);                                                                                             
    push @regions,$chr.":".$strand.":".($region_start_pos-1)."-".($current_pos-1);

    return(@regions);
}

sub read_gencode {
    ## eric note: this has been tested for off-by-1 issues with ucsc brower table output!                                                                                  \
                                                                                                                                                                            
    my $fi = shift;
#    my $fi = "/projects/ps-yeolab/genomes/hg19/gencode_v19/gencodev19_comprehensive";                                                                                      
    print STDERR "reading in $fi\n";
    open(F,$fi);
    while (<F>) {
        chomp($_);
        my @tmp = split(/\t/,$_);
        my $enst = $tmp[1];
        next if ($enst eq "name");
        my $chr = $tmp[2];
        my $str = $tmp[3];
        my $txstart = $tmp[4];
        my $txstop = $tmp[5];
        my $cdsstart = $tmp[6];
        my $cdsstop = $tmp[7];

        my @starts = split(/\,/,$tmp[9]);
        my @stops = split(/\,/,$tmp[10]);

        my @tmp_features;

        my $transcript_type = $enst2type{$enst};
        unless ($transcript_type) {
            print STDERR "error transcript_type $transcript_type $enst\n";
        }
        if ($transcript_type eq "protein_coding") {

            for (my $i=0;$i<@starts;$i++) {
                if ($str eq "+") {
                    if ($stops[$i] < $cdsstart) {
                        # exon is all 5' utr                                                                                                                               \
                                                                                                                                                                            
                        push @tmp_features,$enst."|5utr|".($starts[$i])."-".$stops[$i];
                    } elsif ($starts[$i] > $cdsstop) {
                        #exon is all 3' utr                                                                                                                                \
                                                                                                                                                                            
                        push @tmp_features,$enst."|3utr|".($starts[$i])."-".$stops[$i];
                    } elsif ($starts[$i] > $cdsstart && $stops[$i] < $cdsstop) {
                        #exon is all coding                                                                                                                                \
                                                                                                                                                                            
                        push @tmp_features,$enst."|CDS|".($starts[$i])."-".$stops[$i];
                    } else {
                        my $cdsregion_start = $starts[$i];
                        my $cdsregion_stop = $stops[$i];

                        if ($starts[$i] <= $cdsstart && $cdsstart <= $stops[$i]) {
                            #cdsstart is in exon                                                                                                                           \
                                                                                                                                                                            
                            my $five_region = ($starts[$i])."-".$cdsstart;
                            push @tmp_features,$enst."|5utr|".$five_region;
                            $cdsregion_start = $cdsstart;
                        }

                        if ($starts[$i] <= $cdsstop && $cdsstop <= $stops[$i]) {
                            #cdsstop is in exon                                                                                                                            \
                                                                                                                                                                            
                            my $three_region = ($cdsstop)."-".$stops[$i];
                            push @tmp_features,$enst."|3utr|".$three_region;
                            $cdsregion_stop = $cdsstop;
                        }

                        my $cds_region = ($cdsregion_start)."-".$cdsregion_stop;
                        push @tmp_features,$enst."|CDS|".$cds_region;
                    }
		} elsif ($str eq "-") {
                    if ($stops[$i] < $cdsstart) {
                        # exon is all 5' utr                                                                                                                               \
                                                                                                                                                                            
                        push @tmp_features,$enst."|3utr|".($starts[$i])."-".$stops[$i];
                    } elsif ($starts[$i] > $cdsstop) {
                        #exon is all 3' utr                                                                                                                                \
                                                                                                                                                                            
                        push @tmp_features,$enst."|5utr|".($starts[$i])."-".$stops[$i];
                    } elsif ($starts[$i] > $cdsstart &&$stops[$i] < $cdsstop) {
                        #exon is all coding                                                                                                                                \
                                                                                                                                                                            
                        push @tmp_features,$enst."|CDS|".($starts[$i])."-".$stops[$i];
                    } else {
                        my $cdsregion_start = $starts[$i];
                        my $cdsregion_stop = $stops[$i];

                        if ($starts[$i] <= $cdsstart && $cdsstart <= $stops[$i]) {
                            #cdsstart is in exon                                                                                                                           \
                                                                                                                                                                            
                            my $three_region = ($starts[$i])."-".$cdsstart;
                            push @tmp_features,$enst."|3utr|".$three_region;
                            $cdsregion_start = $cdsstart;
                        }

                        if ($starts[$i] <= $cdsstop && $cdsstop <= $stops[$i]) {
                            #cdsstop is in exon                                                                                                                            \
                                                                                                                                                                            
                            my $five_region = ($cdsstop)."-".$stops[$i];
                            push @tmp_features,$enst."|5utr|".$five_region;
                            $cdsregion_stop = $cdsstop;
                        }

                        my $cds_region = ($cdsregion_start)."-".$cdsregion_stop;
                        push @tmp_features,$enst."|CDS|".$cds_region;
                    }
                }
            }
            for (my $i=0;$i<scalar(@starts)-1;$i++) {
		             # full intron is ($stops[$i]+1)."-".$starts[$i+1]                                                                                                           
                # prox is 500bp                                                                                                                                             

                if ($starts[$i+1]-$stops[$i] > 2 * 500) {
                    if ($str eq "+") {
                        push @tmp_features,$enst."|5ss|".($stops[$i])."-".($stops[$i]+$window_size);
                        push @tmp_features,$enst."|3ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                    } elsif ($str eq "-") {
                        push @tmp_features,$enst."|3ss|".($stops[$i])."-".($stops[$i]+$window_size);
                        push @tmp_features,$enst."|5ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                    }


                    push @tmp_features,$enst."|proxintron|".($stops[$i]+$window_size)."-".($stops[$i]+500);
                    push @tmp_features,$enst."|proxintron|".($starts[$i+1]-500)."-".($starts[$i+1]-$window_size);
                    push @tmp_features,$enst."|distintron|".($stops[$i]+500)."-".($starts[$i+1]-500);
                } else {
                    my $midpoint = int(($starts[$i+1]+$stops[$i])/2);

                    if ($starts[$i+1]-$stops[$i] > 2 * $window_size) {
                        push @tmp_features,$enst."|proxintron|".($stops[$i]+$window_size)."-".($starts[$i+1]-$window_size);

                        if ($str eq "+") {
                            push @tmp_features,$enst."|5ss|".($stops[$i])."-".($stops[$i]+$window_size);
                            push @tmp_features,$enst."|3ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                        } elsif ($str eq "-") {
                            push @tmp_features,$enst."|3ss|".($stops[$i])."-".($stops[$i]+$window_size);
                            push @tmp_features,$enst."|5ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                        }
                    } else {
                        if ($str eq "+") {
                            push @tmp_features,$enst."|5ss|".($stops[$i])."-".($midpoint);
                            push @tmp_features,$enst."|3ss|".($midpoint)."-".$starts[$i+1];
                        } elsif ($str eq "-") {
                            push @tmp_features,$enst."|3ss|".($stops[$i])."-".($midpoint);
                            push @tmp_features,$enst."|5ss|".($midpoint)."-".$starts[$i+1];
                        }
                    }
                }
            }
        } else {


            for (my $i=0;$i<@starts;$i++) {
                push @tmp_features,$enst."|noncoding_exon|".($starts[$i])."-".$stops[$i];
            }
            for (my $i=0;$i<scalar(@starts)-1;$i++) {
                if ($starts[$i+1]-$stops[$i] > 2 * 500) {
                    if ($str eq "+") {
                        push @tmp_features,$enst."|noncoding_5ss|".($stops[$i])."-".($stops[$i]+$window_size);
                        push @tmp_features,$enst."|noncoding_3ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                    } elsif ($str eq "-") {
                        push @tmp_features,$enst."|noncoding_3ss|".($stops[$i])."-".($stops[$i]+$window_size);
                        push @tmp_features,$enst."|noncoding_5ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                    }


                    push @tmp_features,$enst."|noncoding_proxintron|".($stops[$i]+$window_size)."-".($stops[$i]+500);
                    push @tmp_features,$enst."|noncoding_proxintron|".($starts[$i+1]-500)."-".($starts[$i+1]-$window_size);
                    push @tmp_features,$enst."|noncoding_distintron|".($stops[$i]+500)."-".($starts[$i+1]-500);
                } else {
                    my $midpoint = int(($starts[$i+1]+$stops[$i])/2);

                    if ($starts[$i+1]-$stops[$i] > 2 * $window_size) {
                        push @tmp_features,$enst."|noncoding_proxintron|".($stops[$i]+$window_size)."-".($starts[$i+1]-$window_size);

                        if ($str eq "+") {
                            push @tmp_features,$enst."|noncoding_5ss|".($stops[$i])."-".($stops[$i]+$window_size);
                            push @tmp_features,$enst."|noncoding_3ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                        } elsif ($str eq "-") {
                            push @tmp_features,$enst."|noncoding_3ss|".($stops[$i])."-".($stops[$i]+$window_size);
                            push @tmp_features,$enst."|noncoding_5ss|".($starts[$i+1]-$window_size)."-".$starts[$i+1];
                        }
                    } else {
                        if ($str eq "+") {
                            push @tmp_features,$enst."|noncoding_5ss|".($stops[$i])."-".($midpoint);
                            push @tmp_features,$enst."|noncoding_3ss|".($midpoint)."-".$starts[$i+1];
                        } elsif ($str eq "-") {
                            push @tmp_features,$enst."|noncoding_3ss|".($stops[$i])."-".($midpoint);
                            push @tmp_features,$enst."|noncoding_5ss|".($midpoint)."-".$starts[$i+1];
                        }
                    }
                }
            }
        }


        for my $feature (@tmp_features) {
            my ($enst,$type,$region) = split(/\|/,$feature);
            my ($reg_start,$reg_stop) = split(/\-/,$region);
	    next if ($reg_start == $reg_stop);
            my $x = int($reg_start/$hashing_value);
            my $y = int($reg_stop /$hashing_value);
	    
            for my $j ($x..$y) {
                push @{$all_features{$chr}{$str}{$j}},$feature;
            }
        }
    }
    close(F);

}





sub read_gencode_gtf {

#my %gene_types;
    my $file = shift;
#    my $file = "/projects/ps-yeolab/genomes/hg19/gencode_v19/gencode.v19.chr_patch_hapl_scaff.annotation.gtf";
    print STDERR "Reading in $file\n";
    open(F,$file);
    for my $line (<F>) {
	chomp($line);
	next if ($line =~ /^\#/);
	my @tmp = split(/\t/,$line);
	
	my $stuff = $tmp[8];
	my @stufff = split(/\;/,$stuff);
	my ($ensg_id,$gene_type,$gene_name,$enst_id,$transcript_type);
	
	for my $s (@stufff) {
	    $s =~ s/^\s//g;
	    $s =~ s/\s$//g;
	    
	    if ($s =~ /gene_id \"(.+?)\"/) {
		if ($ensg_id) {
		    print STDERR "two ensg ids? $line\n";
		}
		$ensg_id = $1;
	    }
	    if ($s =~ /transcript_id \"(.+?)\"/) {
		if ($enst_id) {
		    prinst DERR "two enst ids? $line\n";
		}
		$enst_id = $1;
	    }
	    if ($s =~ /gene_type \"(.+?)\"/) {
		if ($gene_type) {
		    print STDERR "two gene types $line\n";
		}
		$gene_type = $1;
		
	    }
	    if ($s =~ /transcript_type \"(.+?)\"/) {
		$transcript_type = $1;
	    }
	    if ($s =~ /gene_name \"(.+?)\"/) {
		$gene_name = $1;
	    }
	}

	if (exists $enst2ensg{$enst_id} && $ensg_id ne $enst2ensg{$enst_id}) {
	    print STDERR "error two ensgs for enst $enst_id $ensg_id $enst2ensg{$enst_id}\n";
	}
	$enst2ensg{$enst_id} = $ensg_id;
	$ensg2name{$ensg_id}{$gene_name}=1;
	$ensg2type{$ensg_id}{$gene_type}=1;
	$enst2type{$enst_id} = $transcript_type;
    }
    close(F);
    
}


sub read_lncrna_parsed {
    my $lncfi = shift;
    open(LN,$lncfi);
    for my $line (<LN>) {
	chomp($line);
	my @tmp = split(/\t/,$line);
	my $enst_id = $tmp[2];
	my $ensg_id = "lncRNA|".$tmp[1];
	
	my $gene_name = $tmp[1];
	my $transcript_type = "lncRNA";
	my $gene_type = "lncRNA";
	
	$enst2ensg{$enst_id} = $ensg_id;
	$ensg2name{$ensg_id}{$gene_name}=1;
	$ensg2type{$ensg_id}{$gene_type}=1;
	$enst2type{$enst_id} = $transcript_type;
	
    }
    close(LN);

}
